# Universe.Framework.Core

# Version Control  
For your comfort the project is needed to clone at a local path: C:\P\Universe.Framework.Core\git (but it isn't necessary)
*  master - main working branch, changes are pushing to her through 'MergeRequests' only.
*  develop - second main working branch, changes are pushing to her, same as master, through MergeRequests.

For each task of the development/fixing of an error creates a separate branch.  

*It is created directly from the task, it is necessary to indicate in brackets in English a not very long name of the branch in the task name, errors, before creation.*

## Commit message (notation) generation rules
The message can be multi-line, for example: 
#10 [WebApp Auth]: Adds authorization to the web-application.  
#10 [Common]: Changed links to the projects.  
#10 [Universe.Algorithm, Tests]: Removed an artefact.  

where:
*  #10 - issue number (usually the same as the branch number) - in github it will turn into a link to the issue,
   and when you hover the mouse will be showed the name of the task
*  "WebApp Auth:"" the name of the functional within which the commit is made. Must be specified with a colon at the end.
*  "Adds authorization to the web-application" - text describing, what was done. Required with a dot at the end to complete the sentence.
*  Several actions can be listed and written in this way.
  н-р "#10 WebApp Auth: Connected the Unity container in the WebApp project. Connected the Unity container in the Core project.""

*  [\~] - we specify at the beginning of the commit line if we merge the files manually (git automatically generates a message). The message should look like:  
    [\~] Merge from develop to 11-build-ef-data-access-layer  
    or  
    [\~] Merge from develop to #11  

# Development Tools
For development to use VS 2017, VS2019, VS2022 additionally must be installed:
*  support for PowerShell projects (this is installed when you install VS)
*  git studio integrated (this is installed when VS is installed)
*  ReSharper 2016.2.2 or newer
*  If, after updating from the develop branch, the projects have lost their References, and "NuGet" appears in the error, you can do the following:
    on Solution right click and select and select Restore NuGet Packages. Then Clean solution, build solution.
*  In order for NuGet to automatically restore builds, you need to do the following:
    in the Tools - Options - NuGet Package Manager menu, set 2 checkboxes:
    - Allow NuGet to download missing packages;
    - Automaticall check for missing packages during build in Visual Studio.
*  MSSQL Server 2014 and higher
*  PostgreSQL 10.23 and higher
*  Visual Studio Code 1.42 and above

# Software/platform/library versions
*  MSSQL 2014 SP3 (Build 11.0.6607.3) 
*  PostgreSQL 10.23 and higher

# Pay attention
*  File encoding (especially *.ps1) must be UTF-8

# Coding Style
*  According to the design of the code, adhere to the settings of the resharper in the file ReSharper.DotSettings
*  !Before committing, be sure to reformat the modified code according to the ResharperSln scheme (the exception is cogen and code
  generated by T4 template)
*  When reformatting, select the ResharperSln profile for full reformatting, ResharperSln NoSort for classes that cannot be reordered
*  The catch block, if there is no `throw ...;` in the catch block, then you must specify a comment why it is not here, for example
  as in the example below
  If a new error instance is created in the catch block, then the original error must be specified, or a comment
  why the original error should not be listed.
```c#
catch (Exception ex) {
    _log.Unexpected(ex);
    //throw; Whatever happens here shouldn't affect everything else.
}
````

# Examples of using ...
## Formation of samples according to specific conditions

The project uses an arsenal of filters for more convenient and flexible creation of database queries.
Below is an example of usage:
```c#

   var fieldMapContainer = new FieldMapContainer<TrainsetClassDb> {
                    FieldMap = new Dictionary<string, Expression<Func<TrainsetClassDb, object>>> {
                        {"ClassName", x => x.ClassName},
                    }
                };

    var filters = new List<ConditionConfiguration>();
    foreach (var className in classNamesCollection)
    {
         var filter = new ContainsConfiguration {
			LeftOperand = new FieldArgumentConfiguration {
				Field = new FieldConfiguration {
					SpFieldName = "ClassName",
				}
			},
			RightOperand = new ValueArgumentConfiguration {
				Expression = className
			}
		};
        filters.Add(filter);
    }

    var orFilter = new OrConfiguration {
			Operands = filters
		};

	var result = scope.GetQuery<SelectEntitiesQuery<TrainsetItemDb, TrainsetItemDto>>().Execute(
		new GetEntitiesReq {
			FieldMapContainer = fieldMapContainer,
			Filters = new List<ConditionConfiguration> {
				orFilter
			}
		},
		projection: item => new TrainsetItemDto {
			Id = item.Id,
			ClassName = item.ClassName,
			TrainsetItemValue = item.TrainsetItemValue,
			TrainsetClass = item.TrainsetClassId.HasValue
				? new TrainsetClassDto {
					Id = item.TrainsetClass.Id,
					SessionId = item.TrainsetClass.SessionID,
					TrainSet = item.TrainsetClass.TrainsetId.HasValue
						? new TrainsetDto
						{
							Id = item.TrainsetClass.Trainset.Id,
							Name = item.TrainsetClass.Trainset.Name
						} : null
				} : null
		}
	);
````

 where fieldMapContainer - metainformation for filter initialization. You can also use existing classes with meta-information, eg:
                           var fieldMapContainer = new CaseFilterMetaInfo().FieldMapContainer; 
						   You will can add new conditions to them, if you use them frequently.
						   As a key for the Dictionary element, we specify the matching field, which can be called whatever you like.
						   As a value for the Dictionary element, we specify an Expression that acts as a search field
						   and maybe even from other related tables;

      filters - filter conditions that use the filter model.
				To search using such a filter, it is enough to specify SpFieldName and Expression.
				The value is specified in string format, the value type is determined automatically
				
				Important: the SpFieldName specify, that we have in the meta-information;

	  orFilter = new OrConfiguration - configuration of filters "OR" to search for values included in the range of values of the collection;

	  GetQuery<GetEntitiesQuery<,>>().ExecuteAsync( - this is an asynchronous method that generates a request and
				which takes GetEntitiesReq as an argument, containing filters.
				It also accepts expressions with which to join the tables we need.
				At the same time, it is important to attach the tables by which we select (what is indicated in the FieldMapContainer<>)

## EntityReqHelper - Построитель запросов для EntityFramework

 For typical selections from tables (and related ones), there are extensions for building queries from EntityReqHelper.
  They allow you to use a "shortened" notation for the most common fetch operations.
  Call examples are given below:
 ```c#

 var result = scope.GetQuery<GetEntitiesQuery<TrainsetItemDb>>().Execute(
                    EntityReqHelper.GetInTextsReq(
                        MetaInfoHelper.FieldMap(
                            MetaInfoHelper.MapRule<TrainsetItemDb>(nameof(TrainsetItemDto.Id), x => x.Id),
                            MetaInfoHelper.MapRule<TrainsetItemDb>("ClassName", x => x.TrainsetClass.ClassName)
                        ),
                        searchfieldName: "ClassName",
                        patternValues: new List<string> { "42" },
                        countOnPage: 30,
                        pageIndex: 1
                    ),
                    item => item.TrainsetClass,
                    item => item.TrainsetClass.Trainset
                );


 var result = scope.GetQuery<SelectEntitiesQuery<TrainsetItemDb, TrainsetItemDto>>().Execute(
                    EntityReqHelper.GetEqReq(
                        MetaInfoHelper.FieldMap(
                            MetaInfoHelper.MapRule<TrainsetItemDb>(nameof(TrainsetItemDto.Id), x => x.Id)
                        ),
                        eqfieldName: nameof(TrainsetItemDto.Id),
                        eqvalue: "42",
                        countOnPage: 30,
                        pageIndex: 1
                    ),
                    projection: item => new TrainsetItemDto
                    {
                        Id = item.Id,
                        ClassName = item.ClassName,
                        TrainsetItemValue = item.TrainsetItemValue
                    }
                );

 var result = scope.GetQuery<SelectEntitiesQuery<TrainsetItemDb, TrainsetItemDto>>().Execute(
                    EntityReqHelper.GetNeInReq(
                        MetaInfoHelper.FieldMap(
                            MetaInfoHelper.MapRule<TrainsetItemDb>(nameof(TrainsetItemDto.Id), x => x.Id),
                            MetaInfoHelper.MapRule<TrainsetItemDb>("ClassName", x => x.TrainsetClass.ClassName)
                        ),
                        searchfieldName: "ClassName",
                        antaSearchValues: new List<string> { "2084", "89" },
                        countOnPage: 30,
                        pageIndex: 1
                    ),
                    projection: item => new TrainsetItemDto
                    {
                        Id = item.Id,
                        ClassName = item.ClassName,
                        TrainsetItemValue = item.TrainsetItemValue
                    }
                );

 var result = scope.GetQuery<SelectEntitiesQuery<TrainsetItemDb, TrainsetItemDto>>().Execute(
                    EntityReqHelper.GetInTextsReq(
                        MetaInfoHelper.FieldMap(
                            MetaInfoHelper.MapRule<TrainsetItemDto>(nameof(TrainsetItemDto.Id), x => x.Id),
                            MetaInfoHelper.MapRule<TrainsetItemDto>("ClassName+TrainSetItemValue", x => x.TrainsetClass.ClassName + " " + x.TrainsetItemValue)
                        ),
                        searchfieldName: "ClassName+TrainSetItemValue",
                        patternValues: new List<string> { "89 01011001" },
                        countOnPage: 30,
                        pageIndex: 1
                    ),
                    projection: item => new TrainsetItemDto
                    {
                        Id = item.Id,
                        TrainsetItemValue = item.TrainsetItemValue,
                        TrainsetClass = item.TrainsetClassId.HasValue
                            ? new TrainsetClassDto
                            {
                                Id = item.TrainsetClass.Id,
                                ClassName = item.TrainsetClass.ClassName
                            }
                            : null
                    }
                );
				
````

 where GetQuery<GetEntitiesQuery<>>().Execute( - a method, that generates a request with the full inclusion of the related entity.
              Its argument GetEntitiesReq is formed using EntityReqHelper. Meta information is generated using MetaInfoHelper.FieldMap(),
              and each element containing a mapping and an expression through MetaInfoHelper.MapRule<>.

       searchfieldName - search field - indicates what is in the meta-information;
       patternValues - the value to search for;
       countOnPage - the number of selected elements on the page;
       pageIndex - the page number;
       includes - expressions, that are specified for joining tables.
	   
	 GetQuery<SelectEntitiesQuery<,>>().Execute( - a method that generates a request with the inclusion of a related entity through a projection.
			  Its GetEntitiesReq argument is also formed using the EntityReqHelper. Meta information is generated using MetaInfoHelper.FieldMap(),
              and each element containing a mapping and an expression through MetaInfoHelper.MapRule<>.

## Batch processes - fast mass-saving of large amounts of data.

Usage example:
 ```c#
 
	scope.GetCommand<AddEntitiesBatchCommand<TrainsetDb>>()
		.Execute(x => x.Id, trainSetDb)
		.BatchProcess(
			keySelector: x => x.Id,
			parentEntitiesAfterUpdate: scope
				.GetQuery<SelectEntitiesQuery<TrainsetDb, ExchangeBatchEntity>>().Execute(
					EntityReqHelper.GetEqReq(
						MetaInfoHelper.FieldMap(
							MetaInfoHelper.MapRule<ExchangeBatchEntity>(nameof(ExchangeBatchEntity.Id),
								x => x.Id),
							MetaInfoHelper.MapRule<ExchangeBatchEntity>(
								nameof(ExchangeBatchEntity.SessionId), x => x.SessionId)
						),
						eqfieldName: nameof(ExchangeBatchEntity.SessionId),
						eqvalue: sessionId.ToString(),
						allItemsAsOnePage: true
					),
					projection: s => new ExchangeBatchEntity
					{
						Id = s.Id,
						SessionId = s.SessionID
					}).Items,
			entitiesDict: trainSetDb.TrainsetClasses
				.GroupBy(g => g.Trainset)
				.ToDictionary(g => new ExchangeBatchEntity { Id = g.Key.Id, SessionId = g.Key.SessionID },
					x => x.ToList()),
			parentKeySetterFunc: (items, parentItem) =>
			{
				foreach (var item in items)
				{
					item.Trainset.Id = parentItem.Id;
					item.TrainsetId = parentItem.Id;
				}

				return items;
			})
		.BatchProcess(
			keySelector: x => x.Id,
			parentEntitiesAfterUpdate: scope
				.GetQuery<SelectEntitiesQuery<TrainsetClassDb, ExchangeBatchEntity>>().Execute(
					EntityReqHelper.GetEqReq(
						MetaInfoHelper.FieldMap(
							MetaInfoHelper.MapRule<ExchangeBatchEntity>(nameof(ExchangeBatchEntity.Id),
								x => x.Id),
							MetaInfoHelper.MapRule<ExchangeBatchEntity>(
								nameof(ExchangeBatchEntity.SessionId), x => x.SessionId)
						),
						eqfieldName: nameof(ExchangeBatchEntity.SessionId),
						eqvalue: sessionId.ToString(),
						allItemsAsOnePage: true
					),
					projection: s => new ExchangeBatchEntity
					{
						Id = s.Id,
						SessionId = s.SessionID
					}).Items,
			entitiesDict: trainSetDb.TrainsetClasses.SelectMany(x => x.TrainsetsItems)
				.GroupBy(g => g.TrainsetClass)
				.ToDictionary(g => new ExchangeBatchEntity { Id = g.Key.Id, SessionId = g.Key.SessionID },
					x => x.ToList()),
			parentKeySetterFunc: (items, parentItem) =>
			{
				foreach (var item in items)
				{
					item.TrainsetClass.Id = parentItem.Id;
					item.TrainsetClassId = parentItem.Id;
				}

				return items;
			})
		.BatchProcess(
			keySelector: x => x.Id,
			parentEntitiesAfterUpdate: scope
				.GetQuery<SelectEntitiesQuery<TrainsetItemDb, ExchangeBatchEntity>>().Execute(
					EntityReqHelper.GetEqReq(
						MetaInfoHelper.FieldMap(
							MetaInfoHelper.MapRule<ExchangeBatchEntity>(nameof(ExchangeBatchEntity.Id),
								x => x.Id),
							MetaInfoHelper.MapRule<ExchangeBatchEntity>(
								nameof(ExchangeBatchEntity.SessionId), x => x.SessionId)
						),
						eqfieldName: nameof(ExchangeBatchEntity.SessionId),
						eqvalue: sessionId.ToString(),
						allItemsAsOnePage: true
					),
					projection: s => new ExchangeBatchEntity
					{
						Id = s.Id,
						SessionId = s.SessionID
					}).Items,
			entitiesDict: trainSetDb.TrainsetClasses
				.SelectMany(x => x.TrainsetsItems.SelectMany(y => y.Vectors))
				.GroupBy(g => g.TrainsetItem)
				.ToDictionary(g => new ExchangeBatchEntity { Id = g.Key.Id, SessionId = g.Key.SessionID },
					x => x.ToList()),
			parentKeySetterFunc: (items, parentItem) =>
			{
				foreach (var item in items)
				{
					item.TrainsetItem.Id = parentItem.Id;
					item.TrainsetItemId = parentItem.Id;
				}

				return items;
			});
````

# EntityFramework
## Adding migrations

After model changes in the Universe.DataAccess project, migrations must be added.
To do this, in Visual Studio, go to the "Package Manager Console" window. In it, select the default project
in which changes have been made. Then the Add-Migration command adds a new migration, eg Add-Migration InitialDb.
Before migrating, it is better to run the Update-database -Verbose command.